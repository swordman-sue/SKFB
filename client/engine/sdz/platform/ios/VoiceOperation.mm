#import "VoiceOperation.h"#include "zqcommon/typedef.h"#include "luaengine/luaengine.h"#import <CoreAudio/CoreAudioTypes.h>static  AVAudioRecorder     *voice_recorder = nil;static  AVAudioPlayer           *voice_player = nil;static int recorde_time = 0;static NSTimer  *timer = nil;static int current_max_time = 20;static const int MAX_RECORD_TIME = 20;static unsigned int play_finish_fun_id = 0;static unsigned int play_finish_voice_id = 0;enum VoiceCODE{    VOICE_SUCCESS = 0,			// 成功    VOICE_ERROR,				// 失败    VOICE_FILE_ERROR,			// 文件错误    VOICE_CODE_ERROR,			// 转码错误    VOICE_PARAMETER_ERROR,		// 参数错误    NOT_SUPPORT_INIT_ERRO};//播放完成的监听器@interface PlayFinishListener : NSObject <AVAudioPlayerDelegate>@endstatic  PlayFinishListener     *play_finish_listener = nil;@implementation PlayFinishListener- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer *)player successfully:(BOOL)flag{      [VoiceOperation PlayFinishCallBack :VOICE_SUCCESS];    [VoiceOperation VoicePlayRelease];}- (void)audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)player error:(NSError *)error{      [VoiceOperation PlayFinishCallBack :VOICE_SUCCESS];    [VoiceOperation VoicePlayRelease];}@end@implementation VoiceOperation+ (void)VoiceRecordRelease{    [VoiceOperation stopTimer];    if(voice_recorder && voice_recorder != nil)    {        if(voice_recorder.isRecording)        {            [voice_recorder stop];        }        [voice_recorder release];        voice_recorder = nil;    }}+ (void)VoicePlayRelease{    if(voice_player && voice_player != nil)    {        if(voice_player.isPlaying)        {            [voice_player stop];        }        [voice_player release];        voice_player = nil;    }    if(play_finish_listener != nil)    {        [play_finish_listener release];        play_finish_listener = nil;    }}// 启动定时器+ (void)startTimer{    timer = [NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(updateMeters) userInfo:nil repeats:YES];}// 停止定时器+(void)stopTimer{    if (timer && timer.isValid){        [timer invalidate];        timer = nil;    }}//更新+ (void)updateMeters{        if (recorde_time >= current_max_time){            recorde_time = current_max_time;            [VoiceOperation VoiceRecordRelease];        }else{            recorde_time += 1.0f;        }    }/** 获取录音设置 @returns 录音设置 */+ (NSDictionary*)getAudioRecorderSettingDict{    NSDictionary *recordSetting = [[NSDictionary alloc] initWithObjectsAndKeys:                                   [NSNumber numberWithFloat: 8000.0],AVSampleRateKey, //采样率                                   [NSNumber numberWithInt: kAudioFormatLinearPCM],AVFormatIDKey,                                   [NSNumber numberWithInt:16],AVLinearPCMBitDepthKey,//采样位数 默认 16                                   [NSNumber numberWithInt: 1], AVNumberOfChannelsKey,//通道的数目                                   nil];    return recordSetting;}+(int) StartRecord:(NSString *)source_file_name :(int)secord{        if([source_file_name length] == 0)    {        return VOICE_PARAMETER_ERROR;    }    [VoiceOperation ReleaseVoice];    [VoiceOperation PlayFinishCallBack :VOICE_SUCCESS];    //开始录音    AVAudioSession *audioSession = [AVAudioSession sharedInstance];    NSError *err = nil;    [audioSession setCategory :AVAudioSessionCategoryPlayAndRecord error:&err];    if(err) {        NSLog(@"audioSession: %@ %d %@", [err domain], [err code], [[err userInfo] description]);        return NOT_SUPPORT_INIT_ERRO;    }    [audioSession setActive:YES error:&err];    if(err){        NSLog(@"audioSession: %@ %d %@", [err domain], [err code], [[err userInfo] description]);        return NOT_SUPPORT_INIT_ERRO;    }    UInt32 sessionCategory = kAudioSessionCategory_PlayAndRecord;    AudioSessionSetProperty(kAudioSessionProperty_AudioCategory, sizeof(sessionCategory), &sessionCategory);        NSDictionary *recordSetting = [VoiceOperation getAudioRecorderSettingDict];    //初始化录音    voice_recorder = [[AVAudioRecorder alloc]initWithURL:[NSURL URLWithString:source_file_name]                                                settings:recordSetting error:nil];    [recordSetting release];    if(voice_recorder == nil)    {         NSLog(@"error! StartRecord:sorry!you can not create the voice record instance");         return NOT_SUPPORT_INIT_ERRO;            }    voice_recorder.meteringEnabled = YES;    [voice_recorder prepareToRecord];    [voice_recorder recordForDuration:(NSTimeInterval) 20.0];    //[voice_recorder record];    if(secord > 0){        current_max_time = secord;    }else{       current_max_time = MAX_RECORD_TIME;     }    recorde_time = 0;    //启动计时器    [VoiceOperation startTimer];    return VOICE_SUCCESS;}+(int) StopRecord{     [VoiceOperation VoiceRecordRelease];    return recorde_time;}+(int) StartPlay:(NSString *) full_file_name :(unsigned int)voice_id :(unsigned int) lua_fun_id{    if([full_file_name length] == 0)    {        return VOICE_PARAMETER_ERROR;    }    if (voice_player != nil)    {         [VoiceOperation VoicePlayRelease];    }    [VoiceOperation PlayFinishCallBack :VOICE_SUCCESS];    play_finish_fun_id = lua_fun_id;    play_finish_voice_id = voice_id;    //初始化播放器    AVAudioSession *audioSession = [AVAudioSession sharedInstance];    NSError *err = nil;    [audioSession setCategory :AVAudioSessionCategoryPlayAndRecord error:&err];    if(err) {        NSLog(@"audioSession: %@ %d %@", [err domain], [err code], [[err userInfo] description]);        return NOT_SUPPORT_INIT_ERRO;    }    [audioSession setActive:YES error:&err];    if(err){        NSLog(@"audioSession: %@ %d %@", [err domain], [err code], [[err userInfo] description]);        return NOT_SUPPORT_INIT_ERRO;    }    UInt32 audioRouteOverride = kAudioSessionOverrideAudioRoute_Speaker;    AudioSessionSetProperty (kAudioSessionProperty_OverrideAudioRoute,sizeof (audioRouteOverride),&audioRouteOverride);        voice_player = [[AVAudioPlayer alloc]init];    voice_player = [voice_player initWithContentsOfURL:[NSURL URLWithString:full_file_name] error:nil];    if (voice_player == nil)    {         NSLog(@"error! PlayStart method:sorry!you can not create the voice play instance");        [VoiceOperation PlayFinishCallBack :VOICE_SUCCESS];        return NOT_SUPPORT_INIT_ERRO;    }    voice_player.numberOfLoops = 0;    play_finish_listener = [[PlayFinishListener alloc]init];    voice_player.delegate = play_finish_listener;    [voice_player prepareToPlay];    [voice_player play];    return VOICE_SUCCESS;}+(int) StopPlay{    [VoiceOperation PlayFinishCallBack :VOICE_SUCCESS];    [VoiceOperation VoicePlayRelease];    return VOICE_SUCCESS;    }+(int) ReleaseVoice{    [VoiceOperation VoiceRecordRelease];    [VoiceOperation VoicePlayRelease];    return VOICE_SUCCESS;}+(void) PlayFinishCallBack:(int)code{        if (play_finish_fun_id != 0 && play_finish_voice_id != 0)	{		LuaEngine::GetInstance()->CallFunction(play_finish_fun_id, "IiI",play_finish_fun_id,code,play_finish_voice_id);        play_finish_fun_id = 0;        play_finish_voice_id = 0;	}}@end